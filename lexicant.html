<html>
  <head>
    <title>Lexicant game</title>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700"
    />
    <link rel="stylesheet" href="/style.css" type="text/css" />

    <script src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.23.2/babel.min.js"></script>
    <script src="https://unpkg.com/rxjs@7.8.1/dist/bundles/rxjs.umd.min.js"></script>
    <script>
      async function hackilyImportModule(url) {
        const response = await fetch(url);
        const text = await response.text();

        const exports = {};
        const module = {};
        eval(text);
        return exports.default;
      }

      let immutableUpdate = null;
      async function loadModules() {
        immutableUpdate = await hackilyImportModule(
          "https://unpkg.com/immutability-helper@3.1.1/index.js"
        );
      }
    </script>
  </head>
  <body>
    <div id="main">Loading code...</div>
  </body>

  <script src="/LetterBitMapTrie.js"></script>
  <script src="/Store.js"></script>

  <script type="text/babel">
    async function loadDictionaryNew() {
      const response = await fetch("/dictionary.json");
      const dictionaryWordList = await response.json();
      const set = new Set(
        dictionaryWordList.filter((word) => word.length > 3)
      );
      const trie = new LetterBitMapTrie(set);
      return { set, trie };
    }

    async function loadDictionary() {
      const response = await fetch("/dictionary.json");
      const dictionaryWordList = await response.json();
      const dictionary = new Set(
        dictionaryWordList.filter((word) => word.length > 3)
      );
      const trie = new LetterBitMapTrie(dictionary);
      store.setDictionaryAndTrie(dictionary, trie);
    }

    function Hints({ margin, state }) {
      const [isShown, setIsShown] = React.useState(
        () => !!new URL(window.location).searchParams.get("hints")
      );

      if (state.dictionary == null) {
        return null;
      }
      const { set, trie } = state.dictionary;
      const letters = getLetters(state);

      const apps = trie.append().get(letters);
      const preps = trie.prepend().get(letters);
      const winning_appends = apps.filter(
        (letter) => trie.perfectPlay(letters + letter) === 1
      );
      const winning_prepends = preps.filter(
        (letter) => trie.perfectPlay(letter + letters) === 1
      );
      const safe_appends = apps.filter(
        (letter) => !set.has(letters + letter)
      );
      const safe_prepends = preps.filter(
        (letter) => !set.has(letter + letters)
      );

      return (
        <div style={margin ? { margin } : undefined}>
          <button onClick={() => setIsShown((prev) => !prev)}>
            {isShown ? "Hide" : "Show"} Hints
          </button>
          {isShown && (
            <React.Fragment>
              <div>valid prepends: {preps.join(", ")}</div>
              <div>valid appends: {apps.join(", ")}</div>
              <div>winning prepends: {winning_prepends.join(", ")}</div>
              <div>winning appends: {winning_appends.join(", ")}</div>
              <div>safe prepends: {safe_prepends.join(", ")}</div>
              <div>safe appends: {safe_appends.join(", ")}</div>
            </React.Fragment>
          )}
        </div>
      );
    }

    function PlayedWords({ margin }) {
      const { playedWords } = store.useStoreData();

      return (
        <div style={margin ? { margin } : undefined}>
          Words played this session:
          <pre>{JSON.stringify(playedWords, null, 2)}</pre>
        </div>
      );
    }

    function getComputerMove(state) {
      if (state.gameHistory.length === 0 || state.gameHistory.at(-1).type === "play") {
        if (
            new URL(window.location).searchParams.get("difficulty") === "random"
          ) {
            return getRandomMove(state);
          } else {
            return getOptimalMove(state);
          }
      } else { // challenge
        const { set, trie } = state.dictionary;
        const letters = getLetters(state);
        let [prep, app] = ["", ""];
        while (prep.length + app.length < 40 && !set.has(prep + letters + app)) {
          const action = getRandomValidMove(prep + letters + app, trie);
          if (!action) {
            return { type : "respondToChallenge", isPlayer : false, prepend : "", append : "" };
          }
          if (action.isFront) {
            prep = action.letter + prep;
          } else {
            app = app + action.letter;
          }
        }
        return { type : "respondToChallenge", isPlayer : false, prepend : prep, append : app };
      }
    }

    function getRandomValidMove(letters, trie) {
      const preps = trie.prepend().get(letters);
      const apps = trie.append().get(letters);
      return getActionBySamplingLists(preps, apps);
    }

    function getRandomMove(state) {
      const letter = String.fromCharCode("a".charCodeAt(0) + Math.floor((Math.random() * 26)));
      const pos = Math.random() < .5;
      return { type : "play", letter, isFront : pos, isPlayer : false };
    }

    function getActionBySamplingLists(prepends, appends) {
      const length = prepends.length + appends.length;
      if (length === 0) {
        return undefined;
      }
      const index = Math.floor(Math.random() * length);
      if (index < prepends.length) {
        return { type : "play", letter : prepends[index], isFront : true, isPlayer : false };
      } else {
        return { type : "play", letter : appends[index - prepends.length], isFront : false, isPlayer : false };
      }
    }

    function getOptimalMove(state) {
      const { set, trie } = state.dictionary;
      const letters = getLetters(state);
      if (set.has(letters)) {
        return { type : "declareVictory", isPlayer : false };
      }
      const apps = trie.append().get(letters);
      const preps = trie.prepend().get(letters);
      const winning_appends = apps.filter(
        (letter) => trie.perfectPlay(letters + letter) === 1
      );
      const winning_prepends = preps.filter(
        (letter) => trie.perfectPlay(letter + letters) === 1
      );

      const safe_appends = apps.filter(
        (letter) => !set.has(letters + letter)
      );
      const safe_prepends = preps.filter(
        (letter) => !set.has(letter + letters)
      );

      return getActionBySamplingLists(winning_prepends, winning_appends) ??
              getActionBySamplingLists(safe_prepends, safe_appends) ??
              getActionBySamplingLists(preps, apps) ??
              { type : "challenge", isPlayer : false };
    }

    function Board({ state, dispatch }) {
      return Array.from(getLetters(state)).map((letter, index) => (
                    <div key={index} className="gameBoardLetter">
                      {letter}
                    </div>
                  ));
    }

    function App() {
      const [state, dispatch] = React.useReducer(reducer, undefined, getInitialState);
      console.log(state);
      React.useEffect(() => {
        loadDictionaryNew().then(dictionary => dispatch({ type : "initDict", dictionary }));
      }, []);
      React.useEffect(() => {
        if (state.dictionary == null) {
          return;
        }
        console.log("Computer move might be needed!");
        if (state.gameHistory.length > 0 && state.gameHistory.at(-1).isPlayer) { // && !(state.gameHistory.at(-1).type === "challenge")) {
          console.log(getLetters(state));
          setTimeout(() => dispatch(getComputerMove(state)), 1000);
        }
      }, [state.gameHistory]);
      const { isInitialized, letters, message } = store.useStoreData();

      if (!isInitialized) {
        return <div>Loading dictionary...</div>;
      }

      return (
        <div>
          <h1>Lexicant game</h1>
          <div className="gameBoard">
            <input
              id="prepend"
              type="text"
              maxLength={1}
              className="gameBoardLetter"
              value=""
              onChange={(ev) => updateLetters("front", event.target.value)}
              autoFocus
            />
            {Array.from(letters).map((letter, index) => (
              <div key={index} className="gameBoardLetter">
                {letter}
              </div>
            ))}
            <input
              id="append"
              type="text"
              maxLength={1}
              className="gameBoardLetter"
              value=""
              onChange={(ev) => updateLetters("end", event.target.value)}
            />
          </div>
          <div className="gameBoard">
            <input
              id="prepend"
              type="text"
              maxLength={1}
              className="gameBoardLetter"
              value=""
              onChange={(ev) => dispatch({ type : "play", letter : ev.target.value, isFront : true, isPlayer : true})}
              autoFocus
            />
            <Board state={state} dispatch={dispatch}/>
            <input
              id="append"
              type="text"
              maxLength={1}
              className="gameBoardLetter"
              value=""
              onChange={(ev) => dispatch({ type : "play", letter : ev.target.value, isFront : false, isPlayer : true})}
            />
          </div>
          <button onClick={undo} style={{ marginRight: 12 }}>
            Undo
          </button>
          <button
            onClick={function () {
              dispatch({ type : "challenge", isPlayer : true });
              completeToWord();
              store.setMessage(`I was thinking of \"${store.getLetters()}\"!`);
              resetGame(store.getLetters());
            }}
          >
            Challenge
          </button>
          <Hints margin="12px 0" state={state}/>
          <div>Message: {message}</div>
          <PlayedWords margin="12px 0" />
        </div>
      );
    }

    async function main() {
      await loadModules();
      await loadDictionary();

      ReactDOM.createRoot(document.getElementById("main")).render(<App />);
    }

    const prepend = document.getElementById("prepend");
    const append = document.getElementById("append");

    function updateSequenceInUrl() {
      const url = new URL(window.location);
      url.searchParams.set("sequence", store.getLetters());
      history.pushState({}, "", url);
    }

    function undo() {
      updateLettersHistory("pop");
      updateLettersHistory("pop");
      updateSequenceInUrl();
    }

    function updateLettersHistory(mode, char = null) {
      if (mode === "end") {
        store.setLettersHistory([...store.getLettersHistory(), [char, false]]);
        store.setLetters(store.getLetters() + char);
      } else if (mode === "front") {
        store.setLettersHistory([...store.getLettersHistory(), [char, true]]);
        store.setLetters(char + store.getLetters());
      } else if (mode === "pop") {
        const arr = store.getLettersHistory().at(-1);
        store.setLettersHistory(store.getLettersHistory().slice(0, -1));
        if (arr[1]) {
          store.setLetters(store.getLetters().slice(1));
        } else {
          store.setLetters(store.getLetters().slice(0, -1));
        }
      }
    }

    function updateLetters(mode, char = null) {
      store.setMessage("");
      if (char !== null && !char.match(/[a-z]/i)) {
        if (char === " ") {
          if (document.activeElement === prepend) {
            append.focus();
          } else {
            prepend.focus();
          }
        }
        return;
      }
      char = char.toLowerCase();
      updateLettersHistory(mode, char);
      let letters = store.getLetters();
      if (store.isDictionaryWord(letters)) {
        store.setMessage(letters + " is in the dictionary, you lost");
        resetGame(letters);
      } else {
        if (
          new URL(window.location).searchParams.get("difficulty") === "random"
        ) {
          makeRandomMove(letters);
        } else {
          makeOptimalMove(letters);
        }
        letters = store.getLetters();
        if (store.isDictionaryWord(letters)) {
          store.setMessage(`Word is ${letters}. Computer loses!`);
          resetGame(letters);
        }
      }
      updateSequenceInUrl();
    }

    function makeRandomMove(letters) {
      const trie = store.getTrie();
      const apps = trie.append().get(store.getLetters());
      const preps = trie.prepend().get(store.getLetters());
      if (apps.length + preps.length == 0) {
        updateLettersHistory("pop");
        completeToWord();
        store.setMessage(
          `${letters} has no continuations. I thought we we were building towards \"${store.getLetters()}\"!`
        );
        resetGame(store.getLetters());
      } else {
        const index = Math.floor(Math.random() * (apps.length + preps.length));
        if (index < apps.length) {
          computerAppend(apps[index]);
        } else {
          computerPrepend(preps[index - apps.length]);
        }
      }
    }

    function makeOptimalMove(letters) {
      let apps = store.getTrie().append().get(letters);
      let preps = store.getTrie().prepend().get(letters);
      let winning_appends = apps.filter(
        (letter) => store.getTrie().perfectPlay(letters + letter) === 1
      );

      let winning_prepends = preps.filter(
        (letter) => store.getTrie().perfectPlay(letter + letters) === 1
      );
      //store.setMessage(preps + "<br>" + apps + "<br>" +
      //  winning_appends + "<br>" + winning_prepends)

      let safe_appends = apps.filter(
        (letter) => !store.isDictionaryWord(letters + letter)
      );
      let safe_prepends = preps.filter(
        (letter) => !store.isDictionaryWord(letter + letters)
      );

      if (
        winning_appends.length !== 0 &&
        (winning_prepends.length === 0 || Math.random() > 0.5)
      ) {
        let move = randomChoice(winning_appends);
        computerAppend(move);
      } else if (winning_prepends.length !== 0) {
        let move = randomChoice(winning_prepends);
        computerPrepend(move);
      } else if (
        safe_appends.length !== 0 &&
        (safe_prepends.length === 0 || Math.random() > 0.5)
      ) {
        let move = randomChoice(safe_appends);
        computerAppend(move);
      } else if (safe_prepends.length !== 0) {
        let move = randomChoice(safe_prepends);
        computerPrepend(move);
      } else if (
        apps.length !== 0 &&
        (preps.length === 0 || Math.random() > 0.5)
      ) {
        let move = randomChoice(apps);
        computerAppend(move);
      } else if (preps.length !== 0) {
        let move = randomChoice(preps);
        computerPrepend(move);
      } else {
        updateLettersHistory("pop");
        completeToWord();
        store.setMessage(
          `${letters} has no continuations. I thought we we were building towards \"${store.getLetters()}\"!`
        );
        resetGame(store.getLetters());
      }
    }

    function computerPrepend(letter) {
      updateLettersHistory("front", letter);
    }

    function computerAppend(letter) {
      updateLettersHistory("end", letter);
    }

    function resetGame(endingWord) {
      store.addPlayedWord(endingWord);
      store.resetGame();
    }

    function completeToWord() {
      while (
        !store.isDictionaryWord(store.getLetters()) &&
        store.getLetters().length < 100
      ) {
        makeRandomMove(store.getLetters());
      }
    }

    function randomChoice(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    window.addEventListener("load", main, { once: true });
  </script>
</html>
